Clean Architecture Project Structure
---------------------------------------
Part 1

dotnet new sln --o BuberDinner
more .\BuberDinner.sln เพื่อดู detail ของ solution

dotnet new webapi -o BuberDinner.Api
- Api เป็น Interface ที่ใช้สำหรับเชื่อมต่อ outside world
dotnet new classlib -o BuberDinner.Contracts
- Contracts is a project ที่ model ของ request และ response 
dotnet new classlib -o BuberDinner.Infrastructure
dotnet new classlib -o BuberDinner.Application
dotnet new classlib -o BuberDinner.Domain

dotnet new classlib -o -BuberDinner.Contracts

Api reference Contracts, Infrastructure, Application
dotnet add Api reference Contracts
dotnet add Api reference Infrastructure
dotnet add Api reference Application

Infrastrucuture reference Application
dotnet add Infrastructure reference Application

Application reference Domain
dotnet add Application reference Domain

Application, Infrastructure has own DependencyInjection for easier to manage code 


---------------------------------------
Part 2
implement JWTTokenGenerator by Declare abstractions(Interface) IJwtTokenGenerator at Application and let Infrastructure implements it and configureService in DependencyInjection of Infrastructure

init setter accessor - These properties and indexers can be set at the point of object creation for immutable data purpose เหมือนการทำ get only properties และทำ constructor ที่ set ค่า property นั้น ๆ ได้ก็ต่อเมื่อตอน new object เท่านั้น

create JwtSettings model to map with JwtSettings in appSetting.json
and then add it to IOptions by
services.Configure<JwtSettings>(configuration.GetSection(JwtSettings.SectionName));

To be more secure we can use user-secrets

dotnet user-secrets init --project .\BuberDinner.Api\

dotnet user-secrets set --project .\BuberDinner.Api\ "JwtSettings:Secret" "super-secret-key-from-user-secrets" 
to set user-secret to section in appSetting

dotnet user-secrets list --project .\BuberDinner.Api\ 
to list user-secrets

---------------------------------------
Part 3

Repository is for encapsulate the logic required to access data source
so Repository Class should be in Persistence of Infrastructure and IRepository Interface should be in Persistence of Application
the reason we implement in Infrastructure because we can have many to access data such as using EF core, inMemomy database etc.

---------------------------------------
Part 4
Global Error Handling
Normally if we doesn't have Error Hanlding the response will send error as plain text to client which doesn't good and useful for client.

1. Via Middleware
create middleware class to catch exception of the request
and then add middleware by app.UseMiddleware<ErrorHandlingMiddleware>();
 await _next(context); will invoke endpoint and all inner code of endpoint will be in try catch block
----------------------------------------------------------------------------------------- 
using System.Net;
using System.Runtime.CompilerServices;
using System.Text.Json;

namespace BuberDinner.Api.Middleware;

public class ErrorHandlingMiddleware
{
    private readonly RequestDelegate _next;

    public ErrorHandlingMiddleware(RequestDelegate next)
    {
        _next = next;
    }

    public async Task Invoke(HttpContext context)
    {
        try
        {
            await _next(context);
        }
        catch (System.Exception ex)
        {
            await HandleExceptionAsync(context, ex);
        }
    }

    private static Task HandleExceptionAsync(HttpContext context, Exception ex)
    {
        var code = HttpStatusCode.InternalServerError;
        var result = JsonSerializer.Serialize(new { error = "An error occured while processing your request." });
        context.Response.ContentType = "application/json";
        context.Response.StatusCode = (int)code;
        return context.Response.WriteAsync(result);
    }
}
-----------------------------------------------------------------------------------------


2. Via Filter
create a filter atrribute that will be invoked when exception is not handled is thrown
by create class that inherited from ExceptionFilterAttribute
and add [ErrorHandlingFilterAttribute] at the controller 
or add filter to all controller by add option to AddController services
builder.Services.AddController(options => options.Filters.Add<ErrorHandlingFilterAttribute>());

-----------------------------------------------------------------------------------------